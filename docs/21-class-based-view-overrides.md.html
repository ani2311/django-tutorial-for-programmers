
    <html>
      <head>
        <title>Chapter21</title>
       <meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="style.css">
      </head>
      <body>
<div class="nav">
        <ul>
          <li><a href="index.html">ch00 About this tutorial</a></li>          
          <li><a href="01-before-we-start.md.html">ch01 before we start</a></li>
          <li><a href="02-how-does-django-work.md.html">ch02 how does django work</a></li>
          <li><a href="03-a-new-project.md.html">ch03 a new project</a></li>
          <li><a href="04-run-your-project.md.html">ch04 run your project</a></li>
          <li><a href="05-django-apps.md.html">ch05 django apps</a></li>
          <li><a href="06-first-view.md.html">ch06 first view</a></li>
          <li><a href="07-django-models.md.html">ch07 django models</a></li>
          <li><a href="08-django-admin.md.html">ch08 django admin</a></li>
          <li><a href="09-model-view.md.html">ch09 model view</a></li>
          <li><a href="10-testing.md.html">ch10 testing</a></li>
          <li><a href="11-view-refactoring.md.html">ch11 view refactoring</a></li>
          <li><a href="12-view-refactoring-2.md.html">ch12 view refactoring 2</a></li>
          <li><a href="13-form-view.md.html">ch13 form view</a></li>
          <li><a href="14-django-crispy-form.md.html">ch14 django crispy form</a></li>
          <li><a href="15-django-contrib-auth.md.html">ch15 django contrib auth</a></li>
          <li><a href="16-django-contrib-auth-2.md.html">ch16 django contrib auth 2</a></li>
          <li><a href="17-template-tags-and-ajax.md.html">ch17 template tags and ajax</a></li>
          <li><a href="18-events.md.html">ch18 events</a></li>
          <li><a href="19-class-based-view.md.html">ch19 class based view</a></li>
          <li><a href="20-class-based-view-attributes.md.html">ch20 class based view attributes</a></li>
          <li><a href="21-class-based-view-overrides.md.html">ch21 class based view overrides</a></li>
          <li><a href="22-formsets.md.html">ch22 formsets</a></li>
          <li><a href="23-finishing-touches.md.html">ch23 finishing touches</a></li>
          <li><a href="24-deploy-to-heroku.md.html">ch24 deploy to heroku</a></li>
          <li><a href="25-deploy-to-ubuntu-server.md.html">ch25 deploy to ubuntu server</a></li>
          <li><a href="26-rest-api.md.html">ch26 rest api</a></li>
          <li><a href="27-internationalisation.md.html">ch27 internationalisation</a></li>
          <li><a href="28-logging-data-migration-and-media-files.md.html">ch28 logging data migration and media files</a></li>
          <li><a href="29-template-tags-explained.md.html">ch29 template tags explained</a></li>
          <li><a href="30-moving-on.md.html">ch30 moving on</a></li>
        </ul>
      </div>
        <div id='content'>
    <p>前情提要：</p>
<ol>
<li>[x] 已登入的使用者可以在 store detail view 看到一個按鈕，按下去可以根據該店家建立新 event 讓大家來點餐。</li>
<li>[x] 建立完 event 後進入 event detail view。</li>
<li>[ ] 所有人的點餐都會記錄在 event detail view 裡面。</li>
<li>[ ] 已登入的使用者可以進入 event detail view 填 form 點餐。點完之後頁面會重新整理顯示最新狀態。</li>
<li>[ ] 使用者也可以在同一頁面修改或刪除自己的 order。</li>
</ol>
<p>所以接下來是 3。</p>
<p>打開 <code>events/templates/events/event_detail.html</code>，在</p>
<pre><code class="html language-html">&lt;h1&gt;今天吃：{{ event }}。快點餐！&lt;/h1&gt;
</code></pre>
<p>下面加入一個 table，用來列出點餐記錄：</p>
<pre><code class="html language-html">&lt;table class="table"&gt;
  &lt;thead&gt;
    &lt;tr&gt;&lt;th&gt;使用者&lt;/th&gt;&lt;th&gt;項目&lt;/th&gt;&lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    {% for order in event.orders.all %}
    &lt;tr&gt;&lt;td&gt;{{ order.user }}&lt;/td&gt;&lt;td&gt;{{ order.item }}&lt;/td&gt;&lt;/tr&gt;
    {% endfor %}
  &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p>這個東西現在應該沒什麼好解釋的了。但它目前什麼都不會顯示——因為還沒有辦法點餐。所以首先我們要在新增點餐用的表單：</p>
<pre><code class="python language-python"># events/forms.py

from .models import Order

class OrderForm(forms.ModelForm):

    class Meta:
        model = Order
        fields = ['item', 'notes']

    def __init__(self, *args, submit_title='Submit', **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['item'].empty_label = None
        self.helper = FormHelper()
        self.helper.add_input(Submit('submit', submit_title))
</code></pre>
<p>雖然 <code>Order</code> 有四個欄位，但我們這裡只顯示兩個，因為 <code>user</code> 和 <code>event</code> 要自動帶入。但注意看 <code>__init__</code>，似乎有一行不認識的。</p>
<p>前面說過（好像不止一次），Django 會自動把 foreign key render 成 HTML select widget。但 Django 預設會為每個可能的物件（在這裡就是所有的 menu items）建立一個 option tag，並在最前面加上一個代表空值的 option（預設顯示 <code>------</code> 這樣子）。但點餐時根本不可能什麼都不點吧！所以我們在這裡用 form 的 <code>fields</code> attribute 取出 item 欄位（<code>fields</code> 會回傳一個 dict，其中包含所有表單中的欄位），然後把空值的顯示值設成 <code>None</code>，讓 Django 直接把這個 option tag 拿掉。</p>
<p>接著我們要想辦法把這個 form 丟進 <code>EventDetailView</code>。在 function-based views 中，我們必須初始化一個 form instance，然後把它丟進 <code>render</code> 的 context 參數。在 class-based views 中，則是要 override（暫停三秒製造高潮氣氛）<code>get_context_data</code>！</p>
<pre><code class="python language-python"># events/views.py

from .forms import OrderForm

class EventDetailView(DetailView):

    model = Event

    def get_context_data(self, **kwargs):
        data = super().get_context_data(**kwargs)
        order_form = OrderForm()
        data['order_form'] = order_form
        return data
</code></pre>
<p>我們先用 <code>super()</code> 呼叫 superclass 的 <code>get_context_data</code> 實作，然後在裡面多加一個 <code>OrderForm</code> instance。這樣就可以在 template 中使用了：</p>
<pre><code class="html language-html">{# events/templates/events/event_detail.html #}

{# 千萬要記得它！不然沒辦法用 "crispy" tag！ #}
{% load crispy_forms_tags %}

{# ... #}

{# 加在 content block 的最後面 #}
{% crispy order_form %}

{% endblock content %}
</code></pre>
<p>看起來不錯，不過不太對。我們希望使用者可以點任何這個店家的產品，但<strong>不能點其他店的東西</strong>。現在這樣使用者可以亂點！所以我們要限制使用者能選擇的項目。Django 的 select widget 可以擁有一個 <code>queryset</code> attribute，用來限制能選擇的選項。我們這裡要限制成<strong>所屬店家與目前 event 店家相同的項目</strong>，所以可以這樣寫：</p>
<pre><code class="python language-python"># events/views.py

# ...
def get_context_data(self, **kwargs):
    data = super().get_context_data(**kwargs)
    order_form = OrderForm()
    # 注意這行！
    order_form.fields['item'].queryset = self.object.store.menu_items.all()
    data['order_form'] = order_form
    return data
# ...
</code></pre>
<p>我們限制它必須從當下 event（<code>self.object</code>）所屬店家（<code>store</code>）中的 <code>menu_items</code> 裡面選擇。記得 <code>menu_items</code> 是一個 reverse key，所以會回傳一個 manager；後面的 <code>all</code> 會回傳這個 manager 中的所有物件，所以就是我們想要的限制。</p>
<p>重新整理看看！現在使用者應該只能從當下 event 所屬店家的菜單中選擇了。</p>
<p>記得我們的需求：<strong>已登入的使用者</strong>可以進入 event detail view 填 form 點餐。但現在所有使用者都可以看到 <code>EventDetailView</code>。而且雖然未登入的使用者不會在店家頁面看到按鈕，但如果他直接送一個 POST request（例如用 cURL）給 <code>EventCreateView</code>，還是能建立 event。</p>
<p>在 function-based views 中，我們可以使用 <code>login_required</code> decorator。在 CBV 中也可以這麼做——但要記得，真正被使用的是 <code>as_view()</code> 回傳的 view，所以我們必須覆寫它，自己把 <code>login_required</code> 加上去：</p>
<pre><code class="python language-python">from django.utils.decorators import classonlymethod
from django.contrib.auth.decorators import login_required

class EventDetailView(DetailView):
    # ...
    @classonlymethod
    def as_view(cls, **initkwargs):
        view = super().as_view(**initkwargs)
        return login_required(view)
</code></pre>
<p>不過這如果每次都得這麼做，實在也很麻煩。因為這種權限管理太常見，所以 Django 也已經提供了可重用的功能：</p>
<pre><code class="python language-python">from django.contrib.auth.mixins import LoginRequiredMixin

class EventCreateView(LoginRequiredMixin, CreateView):
    # ...

class EventDetailView(LoginRequiredMixin, DetailView):
    # ...
</code></pre>
<p>現在我們可以保證使用者已經登入，就可以來實作 <code>post</code> 處理使用者點餐：</p>
<pre><code class="python language-python">from django.http import HttpResponseBadRequest
from django.shortcuts import redirect

class EventDetailView(LoginRequiredMixin, DetailView):
    # ...
    def post(self, request, *args, **kwargs):
        form = OrderForm(request.POST)
        if not form.is_valid():
            return HttpResponseBadRequest()
        order = form.save(commit=False)
        order.user = request.user
        order.event = self.get_object()
        order.save()
        return redirect(order.event.get_absolute_url())
</code></pre>
<p>和之前的做法差不多，我們用 <code>request.POST</code> 建立 form，產生 object（但先不要存進資料庫），帶入我們想要的資訊，然後儲存物件，接著重導向回自己（以達到刷新頁面需求）。注意因為 select widget 一定會選擇某個項目（我們之前把空值選項拿掉了），而且 <code>notes</code> 可以為空，使得這個表單的值應該永遠合法，所以我們這裡就不處理。[註 1] 不過如果使用者亂搞，我們會在執行 <code>is_valid</code> 時發現，並回傳一個 400 Bad Request 給他。</p>
<p>在帶入額外資訊時，注意這裡我們不是使用 <code>self.object</code>。如果仔細看看 <code>DetailView</code> 的<a href="http://ccbv.co.uk/projects/Django/1.7/django.views.generic.detail/DetailView/">實作</a>，會發現它在 <code>get</code> method 中才呼叫 <code>get_object</code>，並把它的值賦給 <code>self.object</code>。在進入 <code>post</code> 時，我們不會經過 <code>get</code> method，所以必須自己呼叫 <code>get_object</code>。</p>
<p>大功告成！現在使用者可以點餐，並在上面看到自己與別人的記錄。不過如果使用者已經點過餐，第二次再點就會錯誤——因為我們有設定 <code>unique_together</code>，一個使用者在一個 event 只能點一次餐。根據規格，在這時應該要讓使用者能修改自己的點餐內容。明天繼續！</p>
<hr />
<p>註 1：其實有部分原因是要處理錯誤很麻煩，懶得寫。如果你需要在這裡處理錯誤，繼承 <code>FormView</code> 而非 <code>DetailView</code> 會比較容易實作——或者直接改用一個 function-based view 也可以。Class-based views 不是萬能。</p>

        </div>
        
            </body>
      <script src="common.js"></script>
    </html>